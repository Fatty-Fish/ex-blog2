<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="marking my previous blogs">
<meta name="keywords" content="misfortune follows super luck">
<meta property="og:type" content="website">
<meta property="og:title" content="Fatty-Fish">
<meta property="og:url" content="http://Fatty-Fish.github.io/index.html">
<meta property="og:site_name" content="Fatty-Fish">
<meta property="og:description" content="marking my previous blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fatty-Fish">
<meta name="twitter:description" content="marking my previous blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://Fatty-Fish.github.io/"/>





  <title>Fatty-Fish</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fatty-Fish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">qjfish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/04/27/知道创宇笔试题半解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/知道创宇笔试题半解读/" itemprop="url">知道创宇笔试题半解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-27T20:20:47+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>4月18日，晚上，准备洗漱睡觉的我，看到我邮箱里有前不久在实习僧投递的位于老家四川成都的知道创宇的笔试题。非常开心激动，但点开笔试题我就有点隐隐担心。面试题是这样的：<br><img src="./images/test.png" height="200px"></p>
<p><hr><br>才疏学浅，笔试题里除了mongodb知道，了解过，其他都不知道。Facebook的react听过，一直想要找时间看看文档，还没来得及看，这笔试题目就来了，措手不及，所以啊，机会是留给有准备的人。再说说其中的hapijs，我真没听过，赶紧上网查了一下，是一个在国外很火的框架，国内资料少得可怜，而且还是一家抄。。。而且内容我自己看官网也能明白的。也赶上大理工评估，领导各种作要检查，天天开会，还要背小册子，以防被专家问道答不好。接下来是这一周期限里学到的，以后还会继续深入学习。</p>
<p><hr></p>
<h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>怎么说呢，毕竟看过Vue的文档，做过小项目，所以看react非常轻松，也能很快明白各个功能，各个原理。然后照着 react官网：<br><img src="./images/react1.png"><br>初始化了一个react项目，此时的我已经忘了要用hapijs框架了，所以兴致勃勃的开始了一个登录注册页面，开始尝试用react的各种语法，直到涉及到分配路由时。需要用hapijs框架了。<br>react语法特别多，下面说一说我印象最深刻的几点：</p>
<ol>
<li>JSX<br>JSX是JavaScript的拓展语言，全称是 JavaScript XML ，颠覆传统的js. JSX解析时，遇到 &lt; 就解析为HTML，遇到 { 就解析为JavaScript，react使用这种语法来描述 UI。防止注入攻击：<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scriptDom = &lt;div&gt;&#123;inputContent&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样把用户输入的内容直接插入标签是安全的。因为，默认，react dom 会在渲染 UI 前格式化JSX中的值，所有数据被转化为字符串了。</p>
<p>JSX本质<strong><em> 语法糖</em></strong> ，为React.createElement()方便：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/MyButton&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;<span class="attr">color</span>: <span class="string">'blue'</span>, <span class="attr">shadowSize</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="string">'Click Me'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>**</strong> 好梦，洗洗睡了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/04/19/学习笔记-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/学习笔记-react/" itemprop="url">学习笔记-react</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-19T20:55:23+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>昨天收到远程面试题，惊讶发现要求的题目有我不会的react，hapi.js，没办法只有赶紧自学了。今天早上早起看了react中文文档，和以往一样，比较简单，都是各种组件啥的，用起来应该还可以吧？今天写了联名书，给同学们签字盖手印，交给了负责老师，表明了我们只要证书的决心，我们和老师形成了同一个战队。虽然校园网不稳定，但今晚还又看了一下react，把早上没搞懂的点查了查，总结了几点，明天继续看，任重而道远啊。</p>
<h4 id="ANR报错"><a href="#ANR报错" class="headerlink" title="ANR报错"></a>ANR报错</h4><p>ANR === Application Not Responding，应用程序未响应。<br>一般有三种类型：<strong><em>KeyDispatchTimeout(5 seconds)</em></strong> 是主要类型，按键或触摸事件在5秒内无响应。<strong><em>BroadcastTimeout(10 seconds)</em></strong> 由于BroadcastReceiver（广播接收器，全局监听器，Android四大组件之一，监听 / 接收 应用程序发出的广播消息，并做出响应，具体查看<a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">简书</a>）在10秒内无法处理完成。<strong><em>ServiceTimeout(20 seconds)</em></strong> 是小概率类型，很少出现。Service在20秒内无法处理完成。<br>为什么会处理超时呢？超时时间的计数一般是从 按键分发给app 开始，即按下按键或触摸屏幕那一瞬间。超时的原因一般有两种：(1)当前的事件没有机会得到处理（即UI线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）(2)当前的事件正在处理，但没有及时完成。<br>如何避免超时？第一，UI只做分内事。第二，耗时事件（数据库读写操作，网络请求，I/O请求）开通线程异步处理。第三，使用handler机制处理UI主线程与子线程间任务切换。</p>
<h4 id="UI线程"><a href="#UI线程" class="headerlink" title="UI线程"></a>UI线程</h4><p>谷歌推出UI更新必须在UI线程里的规则。为什么这样做？我看了一个CSDN博主的讲解，<a href="https://blog.csdn.net/sjm19901003/article/details/53394225" target="_blank" rel="noopener">地址</a>，简单理解就是为了移动端用户体验。谷歌Android系统中的控件都不是线程安全的，当多线程使用同一个UI控件，会发生怎样的争抢？但若让控件是线程安全的，那会出现等待，多个线程间会挂起阻塞，移动端用户会先崩溃掉。那怎样解决？<br>所以推出单线程模型，只有这个单线程才负责UI更新，为UI服务，所以就被叫做UI线程。为了保证用户体验，提升效率，这个UI线程不可以执行耗时操作，如果又耗时操作，会报ANR错误。但耗时操作是不可避免的（网络请求，数据库读写）那就只有开通子线程异步去处理，处理完成后通过handler机制通知UI主线程更新UI。<br>来看下handler机制图：<br><img src="./images/UI.jpg" height="300px"></p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个安卓线程运行，会首先单独启动一个process，安卓四大组件：broadcast receiver，content provider，service和activity中后两个都会先跑到process上。一个安卓应用程序对应一个process，此process下有很多线程，其中一个叫做UI线程，在安卓程序运行时被创建，也是一个process中的核心，主线程，main thread。主要负责UI界面的更新显示，控件交互。其他线程负责耗时事件，handler机制负责监听这些线程，当线程上耗时事件被执行完成，信息会被推到UI线程的 message quene 里以触发UI线程里handlermessage函数，UI就知道一个耗时事件已经处理好了，就更新UI界面。</p>
<h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>I/O即Input/Output，中文为进口与出口，有网络IO和磁盘IO，我这里表示想说说磁盘IO读取和写入。有一些重要的参考指标：</p>
<ol>
<li><p>IOPS<br>I/O per second 应该是这样吧，每秒钟的I/O请求数量，是随机访问类型业务的重要指标。对于顺序访问类型，要用传送速度来衡量性能。对于磁盘来说一个完整的IO操作是这样进行的：当控制器对磁盘发出一个IO操作命令的时候，磁盘的驱动臂(Actuator Arm)带动读写磁头(Head)离开着陆区(Landing Zone，位于内圈没有数据的区域)，移动到要操作的初始数据块所在的磁道(Track)的正上方，这个过程被称为<strong><em>寻址(Seeking)</em></strong>，对应消耗的时间被称为<strong><em>寻址时间(Seek Time)</em></strong>;但是找到对应磁道还不能马上读取数据，这时候磁头要等到磁盘盘片(Platter)旋转到初始数据块所在的<strong><em>扇区(Sector)</em></strong>落在读写磁头正上方之后才能开始读取数据，在这个等待盘片旋转到可操作扇区的过程中消耗的时间称为<strong><em>旋转延时(Rotational Delay)</em></strong>;接下来就随着盘片的旋转，磁头不断的读/写相应的数据块，直到完成这次IO所需要操作的全部数据，这个过程称为<strong><em>数据传送(Data Transfer)</em></strong>，对应的时间称为<strong><em>传送时间(Transfer Time)</em></strong>。完成这三个步骤之后一次IO操作也就完成了。被读写的数据可能在磁盘的任意一个磁道，既有可能在磁盘的最内圈(寻址时间最短)，也可能在磁盘的最外圈(寻址时间最长)。和寻址一样，当磁头定位到磁道之后有可能正好停在要读写扇区之上，这时候是不需要额外延时就可以立刻读写到数据，但是最坏的情况可能要磁盘旋转整整一圈之后磁头才能读取到数据。<br>对于单个磁盘，IOPS可以计算。对于有多个磁盘组成的磁盘组，IOPS是不能精确计算的，需要实际测试。对读操作，一般只要cache能足够大，可以大大减少物理IO，而都在cache中进行；对写操作，不论cache有多大，最终的写还是会落到磁盘上。因此，100%写的IOPS要越狱小于100%的读的IOPS。同时，100%写的IOPS大致等同于存储设备能提供的物理的IOPS。</p>
</li>
<li><p>访问类型<br><strong><em>随机访问类型</em></strong>意思是请求的数据在磁盘上位置不连续，请求跨度大，有n个IO请求就得有n次IO请求。与之对应的，还有<strong><em>顺序访问类型</em></strong>，即多个IO请求的数据在磁盘的连续的一块位置，一次IO是有代价的，系统会取完整的一块数据，所以当第一次IO完成时，后续IO请求的数据可能已经有了，这样可以减少IO请求的次数。这也就是所谓的预取。这两种访问类型根据不同场景需求来决定，如果是小文件，数据库的存取，就可以是随机访问类型。如果是视频，音频，大文件，就可以是顺序访问。</p>
</li>
<li>单个IO操作<br>当控制磁盘的控制器接到操作系统的读IO操作指令的时候，控制器就会给磁盘发出一个读数据的指令，并同时将要读取的数据块的地址传递给磁盘，然后磁盘会将读取到的数据传给控制器，并由控制器返回给操作系统，完成一个写IO的操作;同样的，一个写IO的操作也类似，控制器接到写的IO操作的指令和要写入的数据，并将其传递给磁盘，磁盘在数据写入完成之后将操作结果传递回控制器，再由控制器返回给操作系统，完成一个写IO的操作。<strong><em>单个IO操作</em></strong>指的就是完成一个写IO或者是读IO的操作。</li>
<li>顺序IO模式(Queue Mode) 和 并发IO模式(Burst Mode)<br>磁盘控制器可能会一次对磁盘组发出一连串的IO命令，如果磁盘组一次只能执行一个IO命令时称为<strong><em>顺序IO</em></strong>;当磁盘组能同时执行多个IO命令时，称为<strong><em>并发IO</em></strong>。并发IO只能发生在由多个磁盘组成的磁盘组上，<strong><em>单块磁盘只能一次处理一个IO命令。</em></strong></li>
<li>单个IO操作请求的数据的大小(IO Chunk Size)<br>数据库存储有个基本的块大小(Block Size)，不管是SQL Server还是Oracle，默认的块大小都是8KB，就是数据库每次读写都是以8k为单位的。那对于读写磁盘来说单个IO操作数据的大小是多少呢，也固定吗？<br>答案是不确定。首先操作系统为了提高 IO的性能而引入了<strong><em>文件系统缓存</em></strong>（File System Cache），越是高端的存储设备的cache越大，硬盘越多，一方面通过cache异步处理IO，另一方面通过盘数增加，尽可能把IO分布到不同硬盘上，从而提高性能。系统会根据请求数据的情况将多个来自IO的请求先放在缓存里面，然后再一次性的提交给磁盘，也就是说对于数据库发出的多个8K数据块的读操作有可能放在一个磁盘读IO里就处理了。<br>还有对于有些存储系统也是提供了缓存的，接收到操作系统的IO请求之后也是会将多个操作系统的 IO请求合并成一个来处理。不管是操作系统层面的缓存还是磁盘控制器层面的缓存，目的都只有一个，提高数据读写的效率。因此每次单独的IO操作大小都是不一样的，它主要取决于系统对于数据读写效率的判断。<br>当一次IO操作大小比较小的时候我们称作为小的IO操作，比如说1K，4K，8K这样的，这时考验的是IOPS的能力;当一次IO操作的数据量比较大的时候称为大IO操作，比如说32K，64K甚至更大，考验IO系统的IO吞吐量。<br>说到块大小(Block Size)的时候，通常会接触到多个类似的概念，像我们上面提到的那个在数据库里面的数据最小的管理单位，Oralce称之为块(Block)，大小一般为8K，SQL Server称之为页(Page)，一般大小也为8k。<br>在文件系统里面我们也能碰到一个文件系统的块，在现在很多的Linux系统中都是4K(通过 /usr/bin/time -v可以看到)，它的作用其实跟数据库里面的块/页是一样的，都是为了方便数据的管理。但是说到单次IO的大小，跟这些块的大小都是没有直接关系的，在英文里单次IO大小通常被称为是IO Chunk Size，不会说成是IO Block Size的。</li>
<li>IO响应时间(IO Response Time)<br>最后是能直接描述IO性能的IO响应时间。IO响应时间也被称为IO延时(IO Latency)，IO响应时间就是从<strong><em>操作系统</em></strong>内核发出的一个读或者写的IO命令到操作系统内核接收到IO回应的时间，注意不要和单个IO时间混淆了，单个IO时间仅仅指的是IO操作在磁盘内部处理的时间，而IO响应时间还要包括IO操作在IO等待队列中所花费的等待时间。<br>计算IO操作在等待队列里面消耗的时间有一个衍生于利托氏定理(Little’s Law)的排队模型。随着系统实际IOPS越接近理论的最大值，IO的响应时间会成非线性的增长，越是接近最大值，响应时间就变得越大，而且会比预期超出很多。一般来说在实际的应用中有一个70%的指导值，也就是说在IO读写的队列中，当队列大小小于最大IOPS的70%的时候，IO的响应时间增加会很小，相对来说让人比较能接受的，一旦超过70%，响应时间就会戏剧性的暴增，所以当一个系统的IO压力超出最大可承受压力的70%的时候就是必须要考虑调整或升级了。另外补充说一下这个70%的指导值也适用于CPU响应时间，这也是在实践中证明过的，一旦CPU超过70%，系统将会变得受不了的慢。很有意思的东西。<br>———–看了很多博客，才知道的知识，很好玩！这里给个 <a href="https://www.cnblogs.com/94cool/p/5662256.html" target="_blank" rel="noopener">地址</a>都是大神啊。。。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/04/09/gulp构建WX-app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/gulp构建WX-app/" itemprop="url">gulp构建WX-app</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-09T23:05:44+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天不小心错误操作，把微信小程序里的images文件夹里多了几个GIF图片和一个6M的压缩包，然后预览时就超过了限制的2M，于是网上搜索该怎么办啊？</p>
<h4 id="setData"><a href="#setData" class="headerlink" title="setData"></a>setData</h4><p>小程序的视图层和逻辑层是相互独立的模块。视图层是建立于webview容器之上，而逻辑层是javascriptCore运行，数据传输依靠evaluateJavascript执行：数据首先被转换为字符串，字符串被包装为js脚本，再通过脚本执行方式，分别传达给视图层和逻辑层。数据到达视图层并不是实时的。同一个进程内webview共享一个 js VM，而且当webview的js线程同时还在执行其他逻辑渲染时，会延迟evaluateJavascript的执行。而且多个webview会争抢js VM。所以数据传输速度受到影响。</p>
<ol>
<li><p>频繁使用setData</p>
<p> w3cschool给粗案列：</p>
<pre><code>* Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；
* 渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；
</code></pre></li>
<li><p>操作大量新数据</p>
<p> 由上面可知，数据传输是js脚本执行，如果数据过大，必然增加脚本执行负担，拖慢响应速度。</p>
</li>
<li><p>后台态页面进行 setData</p>
<p> “当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。” 这个我想是后台数据传输也用了setData吧，setData是主要视图层与逻辑层数据传输，让用户感受数据改变，既然数据用户都接触不到，就别用setData来占用js线程啦。</p>
</li>
</ol>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。</p>
<ul>
<li><p>图片对内存的影响<br>在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收。</p>
</li>
<li><p>图片对页面切换的影响<br>除了内存问题外，大图片也会造成页面切换的卡顿。我们分析过的案例中，有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。</p>
</li>
</ul>
<p>当前我们建议开发者尽量减少使用大图片资源。</p>
<h5 id="我的图片"><a href="#我的图片" class="headerlink" title="我的图片"></a>我的图片</h5><p>上面说了，我就是失误操作，导致图片过多，都无法预览。当时我想了两种办法：第一种，把图片资源放到easy-mock上，页面加载时get一下。但是我没有找到方法（后续有好方法我会补上）。第二种方法，把微信小程序里的代码用打包工具压缩一下，首先要的就是压缩图片。于是我开通了腾讯云，开通了nodejs环境，想要require一下webpack或者gulp。但是报错了，并没有找到gulp.js<br>如图：<br><img src="./images/tenxunyun.png"><br><img src="./images/package.png"><br><img src="./images/js.png"></p>
<p>后来，我发现，微信小程序自带压缩功能，小程序代码包经过编译后，会放在微信的 CDN 上供用户下载，CDN 开启了 GZIP 压缩，所以用户下载的是压缩后的 GZIP 包，其大小比代码包原体积会更小。如图：<br><img src="./images/auto.png" width="200px" height="100px"><br>所以我还是乖乖去images文件夹下，准备删除一些没用的照片，果然，让我找到了失误粘贴进去的一大堆gif文件和一个压缩包。再次预览，代码打包后只有506kb。果然，微信小程序很强大，自动完成了构建工具完成的任务。</p>
<h4 id="网友们的方法"><a href="#网友们的方法" class="headerlink" title="网友们的方法"></a>网友们的方法</h4><p>看到一个网友，说可以把图片上传到qq空间或者新浪微博，然后登陆，找到图片，复制图片的网络地址！！！这个不是攻城狮应该做的。。。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>微信最开始给我们的代码包限制是1M，但是反应太少了，所以最新版的限制是2M，虽然容量变大了，但是用户初次加载小程序的时间也就相应长了，虽然也就长了可能1s不到，但用户体验会下降。作为前端攻城狮，我们应该注重用户体验，写出高性能的代码，所以还是精良一下，重复的代码就封装为函数吧，图片也少点，或者放到网上。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/04/05/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/promise/" itemprop="url">promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-05T21:19:56+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="单线程的js"><a href="#单线程的js" class="headerlink" title="单线程的js"></a>单线程的js</h4><p>js是单线程的，运行一行执行一行，当遇到需要加载资源的 script 等标签，会阻塞，直到资源加载回来。为了不阻塞，让资源在另一个线程异步加载，可以配置async和defer，defer是IE浏览器适配，加载完成后按照顺序执行，async是其他主流浏览器适配，加载完成即刻执行。还有有src属性的标签自动异步加载，加载完成后会触发onload事件。</p>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p>这里有事件异步：像click事件，需要绑定后才能实现。<br>还有ajax回调函数，但是如果很多ajax请求层层依赖才能实现一个请求，则会嵌套上很多层，代码别人会难读。<br>所以有了promise，可以整理为异步操作执行完成后，链式调用执行回调函数，回调函数仍热有异步操作，还可继续链式调用。更加易读，结构更清晰。</p>
<h4 id="promise简单使用"><a href="#promise简单使用" class="headerlink" title="promise简单使用"></a>promise简单使用</h4><p>promise是一个构造函数。接受一个函数作为参数，函数立即执行。原型上有then方法，管理响应成功或者失败的回调函数。有pending，resolved，rejected三种状态。只能pending-&gt;resolved或者pending-&gt;rejected.<br>promise对象里执行resolved还是执行rejected影响着接下来的then里是执行第一个参数函数还是第二个。也决定了当前promise对象的状态是resolved还是rejected。</p>
<h4 id="promise源码"><a href="#promise源码" class="headerlink" title="promise源码"></a>promise源码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    self.promiseStatus = <span class="string">"pending"</span>;</span><br><span class="line">    self.value = <span class="string">""</span>;</span><br><span class="line">    self.resolvedList = [];</span><br><span class="line">    self.rejectedList = [];</span><br><span class="line">    fn(resolved, rejected);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolved</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.promiseStatus === <span class="string">"pending"</span>) &#123;</span><br><span class="line">            self.promiseStatus === <span class="string">"resolved"</span>;</span><br><span class="line">            self.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (self.resolvedList.length) &#123;</span><br><span class="line">            self.resolvedList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">                ele();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.promiseStatus === <span class="string">"pending"</span>) &#123;</span><br><span class="line">            self.promiseStatus === <span class="string">"rejected"</span>;</span><br><span class="line">            self.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (self.rejectedList.length) &#123;</span><br><span class="line">            self.rejectedList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">                ele();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">"function"</span> ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;; </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (self.promiseStatus === <span class="string">"resolved"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = onResolved(self.value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span> (<span class="params">resolved, rejected</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// val 可能为单纯的值或者promise对象。</span></span><br><span class="line">            <span class="keyword">if</span>(val <span class="keyword">instanceof</span> promise) &#123;</span><br><span class="line">                <span class="comment">// 巧妙：val为promise对象，它的状态决定了整个外面的then的状态，也决定了自己的val.then是执行第一个函数还是第二个函数。在这里都设置为resolved和rejected</span></span><br><span class="line">                val.then(resolved, rejected)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                resolved(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (self.promiseStatus === <span class="string">"rejected"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = onRejected(self.value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span> (<span class="params">resolved, rejected</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val <span class="keyword">instanceof</span> promise) &#123;</span><br><span class="line">                val.then(resolved, rejected)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果val不为promise对象，那整个外面的then不论执行第一个函数还是执行第二个函数，状态都会是resolved，</span></span><br><span class="line">                resolved(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (self.promiseStatus === <span class="string">"pending"</span>) &#123;</span><br><span class="line">        <span class="comment">//promise对象延迟改变状态，但是代码已经执行到它的then了，仍然会return一个promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="keyword">function</span> (<span class="params">resolved,rejected</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//把改变then状态的函数推到两个数组中，将数组在promise对象的resolved或者rejected里执行。即让改变then状态的函数也跟着promise对象的resolved或rejected延迟执行。</span></span><br><span class="line">            self.resolvedList.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//这个函数被保存到list中，形成闭包，作用域链并未释放，</span></span><br><span class="line">                <span class="keyword">var</span> val = onResolved(self.value);</span><br><span class="line">                <span class="keyword">if</span>(val <span class="keyword">instanceof</span> promise) &#123;</span><br><span class="line">                    <span class="comment">// 所以这里的resolved和rejected还是同样的作用</span></span><br><span class="line">                    val.then(resolved, rejected)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    resolved(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            self.rejectedList.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> val = onRejected(self.value);</span><br><span class="line">                <span class="keyword">if</span>(val <span class="keyword">instanceof</span> promise) &#123;</span><br><span class="line">                    val.then(resolved, rejected)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    rejected(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>和then的第二个参数一样，指定rejected的回调<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是catch有个好处，当then里报错，会直接往下执行catch，并把错误信息传到err，打印出，和try，catch语句一样。</p>
<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>Promise.all方法可以让多个异步操作执行完成后，再调用then执行回调。all接收一个数组参数，里面的值最终都是返回Promise对象。这样，多个异步操作的并行执行的，等到它们都执行完后才会进到then里面。异步返回的数据都在then里面，all会把所有异步操作的结果放进一个数组中传给then。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.all([fn1(), fn2(), fn3()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">dataarr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dataarr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p>Promise.race方法和all一样，但是all是最后一个执行完成，进入下一步。而race是一旦有一个就进入下一步。可以应用于图片加载超时执行相应代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.race([imgFn(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当imgFn先执行完成，触发里面的resolved函数，则会执行then。当timeout先执行完成，则会触发里面的rejected函数，则会触发catch函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/03/31/2018阿里在线编程genCssSelector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/2018阿里在线编程genCssSelector/" itemprop="url">2018阿里在线编程genCssSelector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-31T17:32:40+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好吧，我29号中午麻烦了一位好心的小哥哥帮我内推了阿里蚂蚁金服，投了简历，做了在线素质测评…我以为会考些前端基础知识，没想到是一些图表理解，阅读理解，几何智力题，还有心理性格测试题，一脸茫然，紧张的做完了。<br>想着在线编程题会不会也很出人意料呢？就打算第二天下课抽时间做。晚上还是压不住好奇，上网搜了搜大概是什么类型的题，看了最近几年的，好像都涉及递归啊，算法啊，数组啊这类的。都大概自己想了想要怎么做，分析了别人是怎么做的，他的经验等。又看到一个CSDN博主分享了自己18年3月21日做的编程题，，，对的，第二天上午，我点开编程题，就是那道！！！<br>我小小的惊喜了一下，立即开始在我本地的vscode上编程。<br>时间也很紧张，只记得昨天看的时候那个博主有一个localName来获取标签名称，不认识（localNmae是xml语法）所以查了一下。<br>题目是这样的：实现genCssSelector函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"page"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">"content main"</span>&gt;</span><br><span class="line">            main</span><br><span class="line">            &lt;div class=<span class="string">"refer"</span>&gt;</span><br><span class="line">                refer</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;li&gt;li&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;li&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">                    ...</span><br><span class="line"></span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       var genCssSelector = <span class="keyword">function</span> (target) &#123;</span><br><span class="line">            // your code here</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        document.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line"></span><br><span class="line">            //点击li时，返回：html body <span class="comment">#page .content.main .refer ul li</span></span><br><span class="line"></span><br><span class="line">            console.log(genCssSelector(e.target));</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>于是我还是按照我自己想的思路，用递归。<br>可是当我写完，测试出来是undefined，正在准备调试时，时间只有1分多钟了，赶忙把本地代码复制粘贴过去，很混乱，抢着十多秒时间调了一下格式，还没调试完，就自动交卷了…<br>于是沉下心来，看我哪里错了，找出来后，我特别恨自己给自己挖坑。以下是我已经改好的了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var genCssSelector = <span class="keyword">function</span> (target) &#123;</span><br><span class="line">     // your code here</span><br><span class="line">     //arr用于记录最终的name</span><br><span class="line">     var arr = [];</span><br><span class="line">     // find 来实现递归</span><br><span class="line">     <span class="keyword">function</span> find(target) &#123;</span><br><span class="line">         <span class="keyword">if</span> (target.localName) &#123;</span><br><span class="line">             //如果是标签（排除document）</span><br><span class="line">             <span class="keyword">if</span> (target.className) &#123;</span><br><span class="line">                 // 如果有className</span><br><span class="line">                 var str = <span class="string">""</span></span><br><span class="line">                 var arr1 = target.className.split(<span class="string">" "</span>);</span><br><span class="line">                 var len = arr1.length;</span><br><span class="line">                 <span class="keyword">for</span> (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                     str += <span class="string">"."</span> + arr1[i];</span><br><span class="line">                 &#125;</span><br><span class="line">                 arr.push(str);</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.id) &#123;</span><br><span class="line">                 // 如果idName</span><br><span class="line">                 var str = <span class="string">""</span></span><br><span class="line">                 str = <span class="string">"#"</span> + target.id;</span><br><span class="line">                 arr.push(str);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 // 只有标签名</span><br><span class="line">                 arr.push(target.localName)</span><br><span class="line">             &#125;</span><br><span class="line">             //把当前target的父级标签传入find函数</span><br><span class="line">             find(target.parentNode);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //find函数初始自执行</span><br><span class="line">     //find(target);</span><br><span class="line">     //arr此时是一个从里面（li）到外面（html）标签的数组，reverse满足题目要求从外面到里面，数组toString方法将数组合成字符串，replace正则全局匹配<span class="string">","</span>替换为空格。</span><br><span class="line">     <span class="built_in">return</span> arr.reverse().toString().replace(/\,/g, <span class="string">" "</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>说说我交上去的代码错在哪里：第一个，我直接用genCssSelector来实现递归，这样每次arr都会被刷新为[]，所以当然啥也没有了，，，等我下来后改了才增加了find函数。第二个，也没有时间写reverse，toString和replace了，有时间只把arr找出来都不错了，还是自己编程时没有给自己限制时间，每次都take my time，这次跌了个大跤。第三个，我用了一个xml的localName，哈哈哈，这能怪我吗？我当时只记得他了。。。说回来，作为前端开发者需要知道xml的语言才对。localName和nodeName作用一样一样的。</p>
<p>再来看看那位博主的思路：他用的while循环，嗯，非常不错。（其实思路是一样的，只是实现方法不一样。。。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var genCssSelector = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    // your code here</span><br><span class="line">    var path = [];</span><br><span class="line">    var current = arguments[0];</span><br><span class="line">    <span class="keyword">while</span>(current.localName)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current.id)&#123;</span><br><span class="line">            path.push(<span class="string">"#"</span>+current.id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.className)&#123;</span><br><span class="line">            var tmp = current.className.split(<span class="string">" "</span>);</span><br><span class="line">            var str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(var i <span class="keyword">in</span> tmp)&#123;</span><br><span class="line">                str += <span class="string">"."</span>+tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            path.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!current.id &amp;&amp; !current.className)&#123;</span><br><span class="line">            path.push(current.localName)</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    path.reverse();</span><br><span class="line">    <span class="built_in">return</span> path.toString().replace(/\,/g,<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在还在等待面试电话，每天坐立不安，各种复习，看了看准网别人的经验，这几天都在加紧复习promise，nodejs, es6,昨天又再仔细研究了一下promise源码，希望暑期能去实习，非常希望。webpack,vue不虚，因为最近做过项目，还是比较熟悉的。gulp也还不虚，曾经做过项目。希望能面试通过！就算要笔试也不虚！就是想进，就是不怕。。。哈哈哈连我都相信了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/03/31/note1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/note1/" itemprop="url">note1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-31T17:17:36+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Note2"><a href="#Note2" class="headerlink" title="Note2"></a>Note2</h3><p> Posted on 2018-02-06<br>The very essence of romance is uncertainty!</p>
<h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h4><p>call()可以改变this指向：它可以接受很多参数，第一个参数是调用它的函数的this新指向的对象，其余都是调用它的函数的接受的参数。<br>apply()和call()效果一样，区别在于apply只有两个参数，它的第二个参数是一个数组，数组里面是调用它的函数的接受的参数，相当于arguments。</p>
<p>bind()同样改变this指向，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fish = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">fish.bind(&#123;···&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如此，在任何地方，fish函数的this指向都是这个{···}</p>
<h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>数组可以通过for循环，forEach来遍历元素，对象可以用for in枚举：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fish = &#123;</span><br><span class="line">    color:<span class="string">"red"</span>,</span><br><span class="line">    fat: 500</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> fish) &#123;</span><br><span class="line">    console.log(prop, fish[prop])</span><br><span class="line">&#125;</span><br><span class="line">// 输出：<span class="string">"color"</span> <span class="string">"red"</span> <span class="string">"fat"</span> 500</span><br></pre></td></tr></table></figure></p>
<p>但 for in 能输出除了Object.prototype上的属性外，所有原型链上以及对象（fish）自身的所有属性！那问题来了，如果只想要查看自身属性呢？有一个在对象上的方法：Object.prototype.hasOwnProperty(),接受一个属性字符串作为参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fish = &#123;</span><br><span class="line">        color: <span class="string">"red"</span>,</span><br><span class="line">        fat: 500</span><br><span class="line">    &#125;</span><br><span class="line">console.log(fish.hasOwnProperty(<span class="string">"color"</span>)); // <span class="literal">true</span></span><br><span class="line">console.log(Object.prototype.hasOwnProperty.call(fish, <span class="string">"color"</span>)); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>可以判断字符串是否为对象的一个属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fish = &#123;</span><br><span class="line">        color: <span class="string">"red"</span>,</span><br><span class="line">        fat: 500</span><br><span class="line">    &#125;</span><br><span class="line">console.log(<span class="string">"red"</span> <span class="keyword">in</span> fish); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>可以判断对象是否是这个构造函数构造而来，或者说对象的原型链上有无构造函数的原型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fish = &#123;</span><br><span class="line">        color: <span class="string">"red"</span>,</span><br><span class="line">        fat: 500</span><br><span class="line">    &#125;;</span><br><span class="line">console.log(fish instanceof Object); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>总结：判断是对象或者是数组的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第一种：</span><br><span class="line"><span class="keyword">if</span>(O instanceof Array) &#123;</span><br><span class="line">    // <span class="string">"array"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    // <span class="string">"object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是Array来过滤而不是Object,若是Object会无法过滤。数组的原型链上也有Object,在我理解，数组是个特殊的常用的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 第二种：</span><br><span class="line"><span class="keyword">if</span> (O.constructor == Array) &#123;</span><br><span class="line">    // <span class="string">"array"</span> </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    // <span class="string">"object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BUT 这两种方法都只能在同一网页下才能判断，若果是iframe标签或者其他方式嵌套了网页，则通融不了。可以用强大的Object.prototype.toString然后call一下。看返回的是”[object Array]”还是”[object Object]”.</p>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>将类参数列表的值返回最后一个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = (1,2,3,4,5) // arr = 5</span><br><span class="line">var f = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"there is a fish"</span>&#125;,<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"it's a fake fish"</span>&#125;)();</span><br><span class="line">// f = <span class="string">"it's a fake fish"</span> 执行了。</span><br></pre></td></tr></table></figure></p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>代替if else<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fish &gt;= 1000) &#123;</span><br><span class="line">    console.log(<span class="string">"好多鱼"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    console.log(<span class="string">"有鱼"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">fish &gt;= 1000 ? console.log(<span class="string">"好多鱼"</span>):console.log(<span class="string">"有鱼"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>记录执行时函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fish</span></span> () &#123;</span><br><span class="line">    conosle.log(arguments.callee)</span><br><span class="line">&#125;</span><br><span class="line">// 整个fish函数。</span><br></pre></td></tr></table></figure></p>
<h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><p>输出函数执行时函数环境。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">outerFish</span></span> () &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">innerFish</span></span> () &#123;</span><br><span class="line">        console.log(innerFish.caller) // 整个outerFish</span><br><span class="line">    &#125;;</span><br><span class="line">    innerFish();</span><br><span class="line">    console.log(outerFish.caller); // 外部没有函数环境，为null。</span><br><span class="line">&#125;</span><br><span class="line">outerFish();</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/03/31/note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/note/" itemprop="url">note</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-31T17:12:00+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Note1"><a href="#Note1" class="headerlink" title="Note1"></a>Note1</h3><p>Posted on 2018-02-06<br>It’s really cold here ヾ(｡ꏿ﹏ꏿ)ﾉﾞ<br>js是弱类型语言。声明变量不需要规定类型，赋值没有类型检查，还有隐式类型转换包容。<br>来总结下涉及到类型转换的部分方法</p>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>输出变量存的值类型，输出结果都是字符串类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typeof 10</span><br><span class="line">// <span class="string">"number"</span></span><br><span class="line">typeof <span class="string">'fish'</span></span><br><span class="line">// <span class="string">"string"</span></span><br><span class="line">typeof <span class="literal">false</span></span><br><span class="line">// <span class="string">"boolean"</span></span><br><span class="line">typeof null</span><br><span class="line">// <span class="string">"object"</span></span><br><span class="line">typeof undefined</span><br><span class="line">// <span class="string">"undefined"</span></span><br><span class="line">typeof <span class="function"><span class="title">function</span></span> ()&#123;&#125;</span><br><span class="line">// <span class="string">"function"</span></span><br><span class="line">typeof &#123;&#125;</span><br><span class="line">// <span class="string">"object"</span></span><br><span class="line">typeof []</span><br><span class="line">// <span class="string">"object"</span></span><br><span class="line">typeof NaN </span><br><span class="line">// <span class="string">"number"</span></span><br></pre></td></tr></table></figure></p>
<p>这个NaN是Number转换失败的结果，虽然Not a Number，但还是归为Number。<br>JavaScript中值是一个表示值类型的标签和实际值数据一起表示。0标签表示对象，而null空，标签也是0，所以typeof时会返回“object”。<br>[]和{}的判断也是不准确的，可以借助以下Object.prototype.toString.call()或者用Array.isArray()返回的布尔值判断是否为数组。</p>
<h4 id="toString（）"><a href="#toString（）" class="headerlink" title="toString（）"></a>toString（）</h4><p>这是定义在Object.prototype上的方法，所有对象都能使用。Number，String，Array和Boolean都对此方法重写了，Undefined和null不能调用toString。</p>
<p>Number返回为字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">console.log(a.toString()) // <span class="string">"10"</span></span><br><span class="line">console.log(a.toString(2)) // <span class="string">"1010"</span> 把a转换为二进制并返回字符串。</span><br></pre></td></tr></table></figure></p>
<p>String返回为字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">"fatty-fish"</span>;</span><br><span class="line">console.log(a.toString()) // <span class="string">"fatty-fish"</span></span><br></pre></td></tr></table></figure></p>
<p>Array输出每个元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="string">"fish"</span>, 10];</span><br><span class="line">console.log(a.toString()) // <span class="string">"fish,10"</span></span><br></pre></td></tr></table></figure></p>
<p>Boolean返回字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = isNaN(10); // <span class="literal">false</span></span><br><span class="line">console.log(a.toString()) // <span class="string">"false"</span></span><br></pre></td></tr></table></figure></p>
<p>Object调用返回”[object 值类型]”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([])</span><br><span class="line">// <span class="string">"[object Array]"</span></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)</span><br><span class="line">// <span class="string">"[object Object]"</span></span><br><span class="line">Object.prototype.toString.call(10)</span><br><span class="line">// <span class="string">"[object Number]"</span></span><br><span class="line">Object.prototype.toString.call(<span class="string">"fish"</span>)</span><br><span class="line">// <span class="string">"[object String]"</span></span><br><span class="line">Object.prototype.toString.call(null)</span><br><span class="line">// <span class="string">"[object Null]"</span></span><br><span class="line">Object.prototype.toString.call(undefined)</span><br><span class="line">// <span class="string">"[object Undefined]"</span></span><br><span class="line">Object.prototype.toString.call(<span class="function"><span class="title">function</span></span> () &#123;&#125;)</span><br><span class="line">// <span class="string">"[object Function]"</span></span><br><span class="line">Object.prototype.toString.call(<span class="literal">false</span>)</span><br><span class="line">// <span class="string">"[object Boolean]"</span></span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(Number)</span><br><span class="line">// <span class="string">"[object Function]"</span></span><br><span class="line">Object.prototype.toString.call(Boolean)</span><br><span class="line">// <span class="string">"[object Function]"</span></span><br></pre></td></tr></table></figure></p>
<p>所以Object.prototype.toString()方法是非常准确地！只是对他重写了的类型调用时要call一下ヽ(￣▽￣)ノ</p>
<h4 id="Number（）"><a href="#Number（）" class="headerlink" title="Number（）"></a>Number（）</h4><p>会将传入的值尽量转换为Number：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">"fish"</span>)</span><br><span class="line">// NaN</span><br><span class="line">Number(<span class="string">"11"</span>)</span><br><span class="line">// 11</span><br><span class="line">Number(<span class="string">"11a"</span>)</span><br><span class="line">// NaN</span><br><span class="line">Number(undefined)</span><br><span class="line">// NaN</span><br><span class="line">Number([1,1])</span><br><span class="line">// NaN</span><br><span class="line">Number(&#123;&#125;)</span><br><span class="line">// NaN</span><br><span class="line">Number(NaN)</span><br><span class="line">// NaN</span><br><span class="line">Number(<span class="string">''</span>)</span><br><span class="line">// 0</span><br><span class="line">Number(<span class="literal">false</span>)</span><br><span class="line">// 0</span><br><span class="line">Number(null)</span><br><span class="line">// 0</span><br><span class="line">Number([])</span><br><span class="line">// 0</span><br><span class="line">Number([1])</span><br><span class="line">// 1</span><br><span class="line">Number(<span class="literal">true</span>)</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p>
<p>其他Boolean, String等也是尽量强行转为自己人。</p>
<h4 id="isNaN（）"><a href="#isNaN（）" class="headerlink" title="isNaN（）"></a>isNaN（）</h4><p>sth is not a number 返回布尔值。<br>在判断是否 不为数字前，会先Number一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isNaN(<span class="string">"111"</span>) // <span class="string">"111"</span>会Number(<span class="string">"111"</span>) 变为 数字 111后，被isNaN()判断。</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line">isNaN(<span class="string">"red"</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="parseInt（）"><a href="#parseInt（）" class="headerlink" title="parseInt（）"></a>parseInt（）</h4><p>尽量将传入的值转为整型：数字小数点后全舍去。字符串从左往右数到第一位非数字停止。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parseInt(2.2)</span><br><span class="line">// 2</span><br><span class="line">parseInt(10.9)</span><br><span class="line">// 10</span><br><span class="line">parseInt(<span class="string">'10'</span>)</span><br><span class="line">// 10</span><br><span class="line">parseInt(<span class="string">'22a11a'</span>)</span><br><span class="line">// 22</span><br><span class="line">parseInt(1000, 2) // 将1000 看成二进制，再输出对应十进制，2-36进制。</span><br><span class="line">// 8</span><br></pre></td></tr></table></figure></p>
<h4 id="parseFloat（）"><a href="#parseFloat（）" class="headerlink" title="parseFloat（）"></a>parseFloat（）</h4><p>尽量字符串转为十进制数字，且是浮点型数字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(<span class="string">"11.11"</span>)</span><br><span class="line">// 11.11</span><br><span class="line">parseFloat(11.11)</span><br><span class="line">// 11.11</span><br><span class="line">parseFloat(<span class="literal">false</span>)</span><br><span class="line">// NaN</span><br><span class="line">parseFloat(<span class="string">"11a"</span>)</span><br><span class="line">// 11</span><br><span class="line">parseFloat(<span class="string">"11.w1"</span>)</span><br><span class="line">// 11</span><br></pre></td></tr></table></figure></p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>会发生隐式类型转换：<br>加法+ 双目运算符，要两边都为number才会是Number。不然会链接成字符串。</p>
<p>-true ~ -1<br>+undefined ~ NaN<br>“10” &lt; 20 ~ true<br>undefined == null ~ true<br>…and so on!</p>
<p>严格等于<br>全等：“===” 和 不全等：“!==” 不发生类型转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/03/31/继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/继承/" itemprop="url">继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-31T17:04:04+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Inherits"><a href="#Inherits" class="headerlink" title="Inherits"></a>Inherits</h3><p>Posted on 2018-02-04<br>在JS语法中，继承也就是想要共用一些属性，减少代码重复。实现继承只有把想要公用的属性写在原型上，再通过原型链获取。如果想要两个构造函数的实例继承一方的原型上的属性，而且两个构造函数的实例相互独立，自由发展，就需要讨论啦！最好的方法是圣杯式继承。<br>圣杯不是耶稣与他十一个门徒喝的葡萄酒杯子，也不是加勒比海盗里盛人鱼眼泪的圣杯。PS：传说喝下里面的水会返老还童，死而复生并获得永生！但是在这里借用它的意义：永生。</p>
<p>首先先看看别的继承方式为什么不用？</p>
<h4 id="一-传统继承"><a href="#一-传统继承" class="headerlink" title="一.传统继承"></a>一.传统继承</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OldFish.prototype = &#123;</span><br><span class="line">    color: <span class="string">"red"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">OldFish</span></span> () &#123;</span><br><span class="line">    this.fat = 500;</span><br><span class="line">&#125;;</span><br><span class="line">var OOldFish = new OldFish();</span><br><span class="line">YoungFish.prototype = OOldFish; //让target函数的原型指向origin函数的实例。</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">YoungFish</span></span> () &#123;</span><br><span class="line">    this.sex = <span class="string">"female"</span>;</span><br><span class="line">    this.hobbies = &#123;</span><br><span class="line">        dance: <span class="string">"well"</span>;</span><br><span class="line">        food: <span class="string">"spicy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var OYoungFish = new YoungFish();</span><br></pre></td></tr></table></figure>
<p>这种让target函数的原型指向origin函数的实例，来实现继承origin函数的原型上的属性方法的，是有缺陷的：YoungFish会继承老鱼的一身肥肉 this.fat = 500 啊啊,我们只想要单纯的YoungFish继承OldFish.prototype所指向的对象。</p>
<h4 id="二-构造函数继承"><a href="#二-构造函数继承" class="headerlink" title="二.构造函数继承"></a>二.构造函数继承</h4><p>这个有点像 es6 中 class 类之间的继承：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class OldFish &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">        // var this = &#123;&#125;</span><br><span class="line">        this.fat = 500;</span><br><span class="line">        // <span class="built_in">return</span> this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class YoungFish extends OldFish &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">        super(); // 接收OldFish里constructor里返回的this对象。</span><br><span class="line">        this.sex = <span class="string">"female"</span>;</span><br><span class="line">        this.hobbies = &#123;</span><br><span class="line">            dance: <span class="string">"well"</span>;</span><br><span class="line">            food: <span class="string">"spicy"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过super(), 以上YoungFish就继承了OldFish实例的所有属性方法等。<br>而原生的可以用call()方法实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OldFish.prototype = &#123;</span><br><span class="line">    color: <span class="string">"red"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">OldFish</span></span> () &#123;</span><br><span class="line">    // var this = Object.create(OldFish.prototype); </span><br><span class="line">    this.fat = 500;</span><br><span class="line">    // <span class="built_in">return</span> this</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">YoungFish</span></span> () &#123;</span><br><span class="line">    OldFish.call(this);</span><br><span class="line">    this.sex = <span class="string">"female"</span>;</span><br><span class="line">    this.hobbies = &#123;</span><br><span class="line">        dance: <span class="string">"well"</span>;</span><br><span class="line">        food: <span class="string">"spicy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上通过OldFish调用call方法把YoungFish的this传进去，继承的只是实例属性，不能继承老鱼原型上的属性。不符合我们想法。而且每次new YoungFish() 都会执行OldFish.call(this)，这相当于又new OldFish(),不是我们想要的。</p>
<h4 id="三-共享原型"><a href="#三-共享原型" class="headerlink" title="三.共享原型"></a>三.共享原型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OldFish.prototype = &#123;</span><br><span class="line">    color: <span class="string">"red"</span>,</span><br><span class="line">    friends: &#123;</span><br><span class="line">        shrimp: 2000,</span><br><span class="line">        octopus: 30,</span><br><span class="line">        other: 10000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">OldFish</span></span> () &#123;</span><br><span class="line">    // var this = Object.create(OldFish.prototype); </span><br><span class="line">    this.fat = 500;</span><br><span class="line">    // <span class="built_in">return</span> this</span><br><span class="line">&#125;;</span><br><span class="line">YoungFish.prototype = OldFish.prototype; // 简单粗暴的继承！</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">YoungFish</span></span> () &#123;</span><br><span class="line">    this.sex = <span class="string">"female"</span>;</span><br><span class="line">    this.hobbies = &#123;</span><br><span class="line">        dance: <span class="string">"well"</span>;</span><br><span class="line">        food: <span class="string">"spicy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个共享原型的方法可以说简单粗暴，直接共同指向！如果后期操作了YoungFish的原型，那完犊子，OldFish也变了原型。影响太大不好。</p>
<h4 id="四-圣杯式继承"><a href="#四-圣杯式继承" class="headerlink" title="四. 圣杯式继承"></a>四. 圣杯式继承</h4><p>添加一个中介者。写一个继承函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> inherit (target, origin) &#123;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MiddleFish</span></span> () &#123;&#125;; // 造一个空的中介函数</span><br><span class="line">var oMiddleFish = new MiddleFish(); // 产生一个中介函数实例</span><br><span class="line">MiddleFish.prototype = origin.prtotype; // !! 1</span><br><span class="line">target.prototype = oMiddleFish; // !! 2</span><br><span class="line">target.prototype.constructor = target; // !! 3</span><br><span class="line">target.prototype.uber = origin; // !! 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上inherit函数就近乎完美。妙在制造了一个MiddleFish, 其中!! 1和2非常关键，1保证了target能够通过MiddleFish继承origin的prototype上的属性，2保证了target操作自己原型时不影响origin的原型。 因为target操作自己原型，是在MiddleFish的实例上操作，离原型差得远呢。3也很关键，如果没有纠正这一步，target找自己的constructor时，会因为自己的prototype指向“target.prototype = oMiddleFish; // !! 2”找到oMiddleFish, 又因为“MiddleFish.prototype = origin.prtotype; // !! 1”最终找到origin.prototype上的constructor是origin本身。。这不是我们想要的，3会纠正这个走向。4也是必须的，它让target知道自己的上一级是origin。<br>这只是近乎完美，我们想要达到非常完美还得改改：上面的缺陷是每次使用inherit函数，都会请求一片空间，储存一个空函数。这是非常耗费性能的。所以可以形成闭包，重复利用这个空函数。我们可以这样玩：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var MiddleFish = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (target, origin) &#123;</span><br><span class="line">        MiddleFish.prototype = origin.prototype;</span><br><span class="line">        var oMiddleFish = new MiddleFish();</span><br><span class="line">        target.prototype = oMiddleFish;</span><br><span class="line">        target.prototype.constructor = target;</span><br><span class="line">        target.prototype.uber = origin;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>如此便可以复用“var MiddleFish = function () {}”这段代码，perfect</p>
<p>最初会有这种忧虑：作用域链没有被释放，那下一次使用inherit函数时，会不会因为“MiddleFish.prototype = origin.prototype;”把上一个的原型也给改了？？答案：当然不会啦！是引用值啊。因为上一次target.prototype指向oMiddleFish，而oMiddleFish通过–proto–指向MiddleFish.prototype = origin.prototype这个引用值对象。当下一次再来使用inherit函数时，MiddleFish.prototype更改指向，这并不会影响上一次–proto–的指向。而且每个MiddleFish实例都是在MiddleFish.prototype更改指向后创立。所以每个实例自身不一样都是新鲜实例，而且每个实例–proto–所指向的对象也都是正确的origin.prototype所指向的对象。</p>
<p>吃饭！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/03/31/构造函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/构造函数/" itemprop="url">构造函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-31T16:56:06+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一-创建对象"><a href="#一-创建对象" class="headerlink" title="一.创建对象"></a>一.创建对象</h4><p>创建对象可以分为三种方法：</p>
<ol>
<li>对象字面量（对象直接量）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fish = &#123;</span><br><span class="line">    name: <span class="string">"fatty-fish"</span>,</span><br><span class="line">    sex: <span class="string">"who knows"</span>,</span><br><span class="line">    size: 200,</span><br><span class="line">    hobby:<span class="string">"bubble"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>系统自带构造函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fish = new Object(); // &#123;&#125;</span><br><span class="line">var arrFish = new Array(); // []</span><br><span class="line">var dateFish = new Date(); // &#123;&#125;</span><br><span class="line">var numFish = new Number(); // &#123;&#125;</span><br><span class="line">var strFish = new String(); // &#123;&#125;</span><br><span class="line">var bleanFish = new Boolean(); // &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上，五个为系统自带构造函数，都能创建对象，数组是对象，函数是对象，废话。<br>new Number(), new String(), new Boolean()是通过包装类创建的对象，是将原始值（PrimitiveValue）包裹为一个对象。一般是JS为了容错，私下包裹：错误地访问原始值String的长度、为原始值添加属性等等…</p>
<ol start="3">
<li>自定义构造函数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MakeFish</span></span> () &#123;</span><br><span class="line">    this.name = <span class="string">"slim-fish"</span>;</span><br><span class="line">    this.sex = <span class="string">"female"</span>;</span><br><span class="line">    this.size =  100;</span><br><span class="line">    this.hobby = <span class="string">"bubble too"</span>;</span><br><span class="line">&#125;</span><br><span class="line">var fish = new MakeFish();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>像这样，我们就自己构造出一条理想的鱼。</p>
<p>所以，在JS中，Object, Array, function, Date等内部函数都可以创建对象。以及原始值Boolean, String, Number也能被包装成对象。当然撇开undefined和null。</p>
<h4 id="二-自定义构造函数"><a href="#二-自定义构造函数" class="headerlink" title="二.自定义构造函数"></a>二.自定义构造函数</h4><p>那么自定义构造函数是怎样运行的嘞？<br>借用刚才那条理想的鱼，每次创建新对象时，内部是这样做的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MakeFish</span></span> () &#123;</span><br><span class="line">    // var this = &#123;&#125;;</span><br><span class="line">    this.name = <span class="string">"slim-fish"</span>;</span><br><span class="line">    this.sex = <span class="string">"female"</span>;</span><br><span class="line">    this.size =  100;</span><br><span class="line">    this.hobby = <span class="string">"bubble too"</span>;</span><br><span class="line">    // <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">var fish = new MakeFish();</span><br></pre></td></tr></table></figure></p>
<p>所以，我们得到的fish其实是return出来的 this 对象。每次new MakeFish()都会这样流程一遍。所以每条鱼是相互独立的。操作每一条鱼，都是在操作不同的this指代的那个对象。</p>
<p>有这样一道题：结合预编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">    a = 0;</span><br><span class="line">    alert(a);</span><br><span class="line">    alert(this.a);</span><br><span class="line">    var a;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问: test();和 new test(); 窗口分别弹出什么？<br>答：0 5 0 和 0 undefined 0<br>提示：预编译 AO = {this: {}, a: undefined}. 函数执行test()里预编译this指向调用此函数的对象，在这里就是window。而new test() 预编译时，this = Object.create(test.prototype);</p>
<h4 id="三-原型"><a href="#三-原型" class="headerlink" title="三.原型"></a>三.原型</h4><p>分析完构造函数，不得不想起原型…<br>原型也是对象，定义了构造函数实例的共有祖先，也就是实例都可以使用访问的属性，方法。为了节省代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Fish.prototype = &#123;</span><br><span class="line">    color: <span class="string">"red"</span>,</span><br><span class="line">    hobby: <span class="string">"bubble"</span>,</span><br><span class="line">    eat: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">"food"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    family: &#123;</span><br><span class="line">        mother: <span class="string">"AdultFemaleFish"</span>,</span><br><span class="line">        father: <span class="string">"AdultMaleFish"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Fish (size, name) &#123;</span><br><span class="line">    this.size = size;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">var FattyFish = new Fish (200, <span class="string">"Fatty"</span>);</span><br><span class="line">var SlimFish = new Fish (100, <span class="string">"Slim"</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为Fatty 和 Slim 都是红鱼，都有老爸老妈，都喜欢吹泡泡，都可以吃food，所以这些都可以写在prototype上。其它特别的size name就可以自定义。</p>
<p>如果：Slim与众不同，想这样做<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SlimFish.color = <span class="string">"green"</span>;</span><br></pre></td></tr></table></figure></p>
<p>它只是给自己增加了color属性到那个自己独一无二this对象里，并没有改变原型上的color。当SlimFish再次访问color属性时，会先从自己那里找到。</p>
<p>如果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SlimFish.prototype.color = <span class="string">"green"</span>; // 报错：Uncaught TypeError: Cannot <span class="built_in">set</span> property <span class="string">'color'</span> of undefined</span><br></pre></td></tr></table></figure></p>
<p>因为SlimFish并没有prototype属性???</p>
<p>如果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SlimFish.family.mother = <span class="string">"AdultMaleFish"</span>;</span><br></pre></td></tr></table></figure></p>
<p>此时，family是在原型上，且指针指向引用值，当SlimFish更改family.mother时，是真的黑进了族谱（引用值）…当FattyFish访问族谱时，就得到mother是”AdultMaleFish” !!!</p>
<h4 id="四-proto"><a href="#四-proto" class="headerlink" title="四.proto"></a>四.proto</h4><p>问题来了：SlimFish并没有prototype属性，她通过什么改变了族谱的呢？————proto<br>为了让构造函数的实例和他们共有的祖先链接起来，js引擎为每个实例提供了一个隐式属性proto,这个隐式属性指针指向Fish.prototype所指向的对象，也就是他们的共有祖先。他们的共有祖先也是个对象，也有proto，这些proto连接起来，形成了原型链，任何一条鱼沿着proto往上追根溯源，都会找到Object.prototype所指向的引用值，然后接着向上游，是null !!! 所以一切皆对象！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null; // <span class="string">"object"</span></span><br></pre></td></tr></table></figure></p>
<p>如果，想创造一个没有proto属性的对象，可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var SmileFish = Object.create(null);</span><br></pre></td></tr></table></figure></p>
<p>意思是创造一个原型为null的SmileFish<br>SmileFish的proto按照约定会指向null所指向的对象，然而null是原始值，它并不指向任何对象，所以SmileFish就没有proto.</p>
<h4 id="五-constructor"><a href="#五-constructor" class="headerlink" title="五.constructor"></a>五.constructor</h4><p>constructor 也是像proto一样，是实例的一个隐式属性，指向实例的构造函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(FattyFish.constructor); // native code Object </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">BadFish</span></span> () &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">var EndFish = new BadFish ();</span><br><span class="line">console.log(EndFish.constructor) //<span class="keyword">function</span> BadFish</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Fatty-Fish.github.io/2018/03/31/预编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fatty-Fish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/预编译/" itemprop="url">预编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-31T16:48:33+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写在前面：…我更换了电脑系统，没想到导致以前的blog文件丢失了…万般无奈，心痛，在DELETE之前仓库之前，访问了最后一次我的blog，并复制了我觉得历经千辛万苦才写出的文字，在这里再次展出来。中午发现丢失，直到现在才搞好…中间又踩了很多坑比如：npm上和cnpm上下载的hexo版本不同了，一查发现hexo两天前更新了):……(:</p>
<h4 id="一-introduction"><a href="#一-introduction" class="headerlink" title="一.introduction"></a>一.introduction</h4><p>今天回头看了看，觉得函数执行前预编译可以拿出来讲讲。因为这其中涉及一些页面运行顺序步骤，和函数执行的内部情况，作用域链等等，可以帮我们很好地了解函数作用域，全局变量和局部变量，页面运行背后经历了什么。</p>
<h4 id="二-基础概念"><a href="#二-基础概念" class="headerlink" title="二.基础概念"></a>二.基础概念</h4><p>JS是解释型语言，解一行，运行一行，在解码前会检查语法错误。首先深入了解一些如下基本概念。</p>
<h5 id="2-1-全局对象GO-global-object"><a href="#2-1-全局对象GO-global-object" class="headerlink" title="2.1 全局对象GO (global object)"></a>2.1 全局对象GO (global object)</h5><p>在浏览器环境下，整个js会执行前创建GO对象，对象里有document是一个{}，还有全局的变量以及function，还有this是指向window，然后window是一个{}，所以可以看做global对象就是window对象，所以window和window的所有属性可以再任何地方被访问，也就是全局变量。全局变量由三种情况产生：</p>
<ol>
<li>在最外层被定义</li>
<li>定义为window的属性</li>
<li>未定义直接赋值即暗示全局变量</li>
</ol>
<p>在nodejs环境下，直接就是global对象，global和global的所有属性可以再任何地方被访问。与浏览器环境下相比，nodejs下的全局变量不可能在最外层被定义，因为没有最外层，只有当前模块。</p>
<p>所以需要注意：一定养成var声明变量当然还有es6 let,const等，以免造成暗示全局变量，污染命名空间。</p>
<h5 id="2-2-活动对象AO-action-object"><a href="#2-2-活动对象AO-action-object" class="headerlink" title="2.2 活动对象AO (action object)"></a>2.2 活动对象AO (action object)</h5><p>运行期上下文：是一个作用域，代码执行的环境，有函数级别下的运行期上下文，也有全局的运行期上下文。函数级别的是指函数被调用时，但是函数真正执行前，所创建的一个内部对象。函数每次执行时，都会重新创建一个运行期上下文，并且执行完毕就立即销毁。所以有时会借用形成闭包，让运行期上下文不被销毁，造累加器，或者实现缓存…讲远了<br>AO就是函数运行期上下文，一个作用域。函数被调用时，执行前，预编译而创建。分为四步：</p>
<ol>
<li>创建AO对象{this:{proto:,constructor:,},arguments:[]}</li>
<li>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined: {this:{proto:,constructor:},arguments:[], 变量名:undefined, 形参名:undefined}</li>
<li>形参实参相统一：{this:{proto:,constructor:},arguments:[], 变量名:undefined, 形参名:实参}</li>
<li>在函数体内找函数声明，值赋予函数体：{this:{proto:,constructor:},arguments:[], 变量名:undefined, 形参名:实参, 函数: 函数}.<br>这就是预编译，至此四步，创建完毕。<br>可以发现，AO很像GO。感觉整个js是个最外层的大函数，它也会预编译，不过形成的AO就很厉害，叫做GO。</li>
</ol>
<h5 id="2-3-scope"><a href="#2-3-scope" class="headerlink" title="2.3 [[scope]]"></a>2.3 [[scope]]</h5><p>JavaScript是面向对象的语言，函数function是其中一个对象，而[[scope]]是函数的一个属性，程序员不可访问，不可读，不可写，仅仅提供给JavaScript引擎存取。[[scope]]也是一个对象，存储着执行期上下文的集合，这个集合呈链式连接，此链接叫做作用域链：scope chain！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">demoA</span></span> () &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">demoB</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    demoB();</span><br><span class="line">&#125;;</span><br><span class="line">demoA();</span><br></pre></td></tr></table></figure>
<p>以上，定义demoA：demoA.[[scope]] = {0:GO};<br>执行demoA时，创建活动对象AO(以aAO表示): demoA.[[scope]] = {0:aAO, 1GO};<br>执行demoA时，demoB被定义：demoB.[[scope]] = {0:demoA.[[scope]]};<br>执行demoB时，创建活动对象AO(以bAO表示)：demoB.[[scope]] = {0:bAO, 1:demoA.[[scope]]}; 即{0:bAO, 1:aAO, 2:GO};<br>所以当demoB查找变量时，会先从bAO里找，没有找aAO，再GO，GO没有则报错：”sth is not defined”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="qj" />
          <p class="site-author-name" itemprop="name">qj</p>
           
              <p class="site-description motion-element" itemprop="description">marking my previous blogs</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qj</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
